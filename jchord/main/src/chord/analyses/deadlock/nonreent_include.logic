// Created by convert.py from ./src/chord/analyses/deadlock/nonreent_include.dlog on 2015-04-20 13:08:42.242677
// # Copyright (c) 2008-2010, Intel Corporation.
// # Copyright (c) 2006-2007, The Trustees of Stanford University.
// # All rights reserved.
// # Licensed under the terms of the New BSD License.

// # Author: Mayur Naik (mhn@cs.stanford.edu)
// :name: deadlock-nonreent-include-dlog

// :domains: M
// :domains: V
// :domains: A
// :domains: L
// :domains: I
// :domains: H


// ###
// # Relations
// ###

// :inputs: ML(M,L)
// :inputs: MI(M,I)
// :inputs: threadAM(A,M)
// :inputs: IM(I,M)
// :inputs: threadStartI(I)
// :inputs: syncLH(L,H)
// :inputs: transLL(L,L)
// :inputs: transLI(L,I)

// convert.py: following intermediate relation converted to output relation
// :outputs: mayAliasedUptoL(L)
mayAliasedUptoL(n) -> L(n).
// convert.py: following intermediate relation converted to output relation
// :outputs: notAliasedUptoL(L)
notAliasedUptoL(n) -> L(n).

// convert.py: following intermediate relation converted to output relation
// :outputs: mayAliasedUptoLI(L,I)
mayAliasedUptoLI(n,i) -> L(n), I(i).
// convert.py: following intermediate relation converted to output relation
// :outputs: notAliasedUptoLI(L,I)
notAliasedUptoLI(n,i) -> L(n), I(i).

// convert.py: following intermediate relation converted to output relation
// :outputs: syncML(M,L)
syncML(m,n) -> M(m), L(n).
// convert.py: following intermediate relation converted to output relation
// :outputs: syncIL(I,L)
syncIL(i,n) -> I(i), L(n).

// convert.py: following intermediate relation converted to output relation
// :outputs: syncMLL(M,L,L)
syncMLL(m,l1,l2) -> M(m), L(l1), L(l2).
// convert.py: following intermediate relation converted to output relation
// :outputs: syncILL(I,L,L)
syncILL(i,l1,l2) -> I(i), L(l1), L(l2).
// :outputs: syncTLL(A,L,L)
syncTLL(t,l1,l2) -> A(t), L(l1), L(l2).

// ###
// # Constraints
// ###

mayAliasedUptoLI(n,i) <- transLI(l2,i), syncLH(n,o), syncLH(l2,o).
mayAliasedUptoL(n) <- transLL(l1,n), syncLH(l1,o), syncLH(n,o).

notAliasedUptoLI(n,i) <- !mayAliasedUptoLI(n,i).
notAliasedUptoL(n) <- !mayAliasedUptoL(n).

syncML(m,l) <- notAliasedUptoL(l), ML(m,l).
syncIL(i,l) <- IM(i,m), syncML(m,l), !threadStartI(i).
syncML(m,l) <- syncIL(i,l), MI(m,i), notAliasedUptoLI(l,i).

syncMLL(m,l1,l2) <- transLI(l1,i), MI(m,i), syncIL(i,l2), notAliasedUptoLI(l2,i), notAliasedUptoL(l1).

syncMLL(m,l1,l2) <- transLL(l1,l2), ML(m,l1), ML(m,l2), notAliasedUptoL(l1), notAliasedUptoL(l2).

syncILL(i,l1,l2) <- IM(i,m), syncMLL(m,l1,l2), !threadStartI(i).

syncMLL(m,l1,l2) <- MI(m,i), syncILL(i,l1,l2), notAliasedUptoLI(l1,i), notAliasedUptoLI(l2,i).

syncTLL(t,l1,l2) <- threadAM(t,m), syncMLL(m,l1,l2).


